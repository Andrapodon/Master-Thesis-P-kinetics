---
title: "Master Thesis"
subtitle: "P-release kinetic as a predictor for P-availability in the STYCS Trials"
author: "Marc Jerónimo Pérez y Ropero"
format: 
  revealjs:
    smaller: true
    scrollable: true
    embed-resources: true
    theme: dracula
    incremental: true
---

```{r setup}
#| include: false
#| message: false
#| warning: false


suppressPackageStartupMessages({
  library(multcomp)
  library(car)
  library(tidyr)
  library(lme4)
  library(ggplot2)
  library(ggtext)
  library(ggpmisc)
  library(nlme)
  library(latex2exp)
  library(kableExtra)
  library(broom)
  library(dplyr)
  library(MuMIn)
  library(kableExtra)
  library(dplyr)
  library(lmerTest)

})

options(warn = -1)
load("~/Documents/Master Thesis/Master-Thesis-P-kinetics/data/results_coefficient_analysis")
RES <- readRDS("~/Documents/Master Thesis/Master-Thesis-P-kinetics/data/RES.rds")
d <- d[d$Site!="Cadenazzo",]

D <- RES$D2

# 'd' is your starting dataframe with all 2017-2022 data

# This single command creates your final, ready-to-use dataframe.
D <- D %>%
  # First, convert all categorical columns to factors.
  mutate(across(c(site, Site, Treatment, Rep,rep, block, year, uid, ui, location), as.factor)) %>%
  
  # SECOND, on that same dataframe, scale all the columns that are still numeric.
  mutate(across(where(is.numeric), scale))

# That's it! 'd_prepared_for_modeling' is the only dataframe you need.
# It contains both your factor columns and your scaled numeric columns.
# You can now use it directly in your lmer() models.

fit.soil.PS  <- lmer(log(PS)     ~ soil_0_20_clay+ soil_0_20_pH_H2O + soil_0_20_Corg + soil_0_20_silt + Feox + Alox  + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)
# fit.soil.PS2 <- lmer(log(PS)     ~ soil_0_20_clay+ soil_0_20_pH_H2O + soil_0_20_Corg + soil_0_20_silt  + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)
fit.soil.k   <- lmer(k           ~ soil_0_20_clay+ soil_0_20_pH_H2O + soil_0_20_Corg + soil_0_20_silt + Feox + Alox + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)
fit.soil.kPS <- lmer(I(k*PS)~ soil_0_20_clay+ soil_0_20_pH_H2O + soil_0_20_Corg + soil_0_20_silt + Feox + Alox + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)
fit.soil.kPS2<- lmer(I(k*log(PS))~ soil_0_20_clay+ soil_0_20_pH_H2O + soil_0_20_Corg + soil_0_20_silt + Feox + Alox + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)
fit.soil.CO2 <- lmer(soil_0_20_P_CO2~ soil_0_20_clay+ soil_0_20_pH_H2O + soil_0_20_Corg + soil_0_20_silt + Feox + Alox + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)
fit.soil.AAE10<-lmer(soil_0_20_P_AAE10~ soil_0_20_clay+ soil_0_20_pH_H2O + soil_0_20_Corg + soil_0_20_silt + Feox + Alox + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)

fit.kin.Yrel     <- lmer(Ymain_rel         ~ k * log(PS)  + (1|year) + (1|Site)  + (1|Site:block), D)
fit.grud.CO2.Ynorm     <- lmer(Ymain_norm    ~ log(soil_0_20_P_CO2) + (1|year) + (1|Site)  + (1|Site:block), D, subset = Treatment != "P166")
r.squaredGLMM(fit.grud.CO2.Ynorm)
fit.grud.AAE10.Ynorm   <- lmer(Ymain_norm    ~ log(soil_0_20_P_AAE10) + (1|year) + (1|Site)  + (1|Site:block), D, subset = Treatment != "P166")
r.squaredGLMM(fit.grud.AAE10.Ynorm)
fit.grud.CO2.AAE10.Ynorm <- lmer(Ymain_norm  ~ log(soil_0_20_P_CO2) * log(soil_0_20_P_AAE10) + (1|year) + (1|Site)  + (1|Site:block), D, subset = Treatment != "P166")
r.squaredGLMM(fit.grud.CO2.AAE10.Ynorm)
# compare with k*log(PS)
fit.kin.Ynorm   <- lmer(Ymain_norm       ~ k*log(PS) + (1|year) + (1|Site)  + (1|Site:block), D, subset = Treatment != "P166")
r.squaredGLMM(fit.kin.Ynorm)

fit.kin.Ynorm    <- lmer(Ymain_norm       ~ k * log(PS) + (1|year) + (1|Site)  + (1|Site:block), D, subset = Treatment != "P166")
fit.kin.Pexport  <- lmer(annual_P_uptake  ~ k * log(PS) + (1|year) + (1|Site)  + (1|Site:block), D)
fit.kin.Pbalance <- lmer(annual_P_balance ~ k * log(PS) + (1|year) + (1|Site)  + (1|Site:block), D)

fit.grud.PS       <- lm(log(PS)         ~ log(soil_0_20_P_CO2) + log(soil_0_20_P_AAE10), D)
fit.grud.k        <- lm(k               ~ log(soil_0_20_P_CO2) + log(soil_0_20_P_AAE10), D)
fit.grud.kPS      <- lm(I(log(k*PS))    ~ log(soil_0_20_P_CO2) + log(soil_0_20_P_AAE10), D)

fit.grud.CO2.Yrel     <- lmer(Ymain_rel       ~ log(soil_0_20_P_CO2) + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)
fit.grud.AAE10.Yrel     <- lmer(Ymain_rel       ~ log(soil_0_20_P_AAE10) + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)
fit.grud.Yrel     <- lmer(Ymain_rel       ~ log(soil_0_20_P_CO2) * log(soil_0_20_P_AAE10) + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)


# this is hopeless, since cannot log becaus of 0's
fit.CO2.Pexport     <- lmer(annual_P_uptake     ~ log(soil_0_20_P_CO2) + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)

fit.AAE10.Pexport     <- lmer(annual_P_uptake ~ log(soil_0_20_P_AAE10) + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)

fit.grud.Pexport     <- lmer(annual_P_uptake     ~ log(soil_0_20_P_CO2) * log(soil_0_20_P_AAE10) + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)


fit.CO2.Pbalance     <- lmer(annual_P_balance      ~ log(soil_0_20_P_CO2)  + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)


fit.AAE10.Pbalance     <- lmer(annual_P_balance      ~ log(soil_0_20_P_AAE10)  + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)


fit.grud.Pbalance     <- lmer(annual_P_balance      ~ log(soil_0_20_P_CO2) * log(soil_0_20_P_AAE10)  + (1|year) + (1|Site)  + (1|Site:block) + (1|Site:Treatment), D)

lmer_models <- list(
  PS = fit.soil.PS,
  k = fit.soil.k,
  'log(k*PS)' = fit.soil.kPS,
  CO2 = fit.soil.CO2,
  AAE10 = fit.soil.AAE10
)



lmer_models_yield_norm <- list(
  "Yn-STP-CO2" = fit.grud.CO2.Ynorm,
  "Yn-STP-AAE10" = fit.grud.AAE10.Ynorm,
  "Yn-STP-GRUD" = fit.grud.CO2.AAE10.Ynorm,
  "Yn-Kinetic" = fit.kin.Ynorm,
  "Yr-STP-CO2" = fit.grud.CO2.Yrel,
  "Yr-STP-AAE10" = fit.grud.AAE10.Yrel,
  "Yr-STP-GRUD" = fit.grud.Yrel,
  "Yr-Kinetic" = fit.kin.Yrel
)

lmer_models_balance <- list(
  CO2_Pbalance = fit.CO2.Pbalance,
  AAE10_Pbalance = fit.AAE10.Pbalance,
  Grud_Pbalance = fit.grud.Pbalance,
  Kin_Pbalance = fit.kin.Pbalance
)

lmer_models_export <- list(
  CO2_Pexport = fit.CO2.Pexport,
  AAE10_Pexport = fit.AAE10.Pexport,
  Grud_Pexport = fit.grud.Pexport,
  Kin_Pexport = fit.kin.Pexport
)


```



```{r}
#| echo: false
create_coef_table <- function(lmer_models, 
                              covariate_order = NULL, 
                              covariate_labels = NULL, # NEU: Benannter Vektor für Zeilennamen
                              model_labels = NULL,
                              descriptor = "Response") {   # NEU: Benannter Vektor für Spaltennamen

  # Extract coefficients and p-values (Ihre Originalfunktion, keine Änderung hier)
  extract_coef_info <- function(model) {
    # ... (keine Änderung, Ihr Code bleibt hier)
    coef_matrix <- summary(model)|> coef()
    estimates <- coef_matrix[, 1]
    p_values <- coef_matrix[, ncol(coef_matrix)]
    formatted_coef <- sapply(seq_along(estimates), function(i) {
      est_str <- sprintf("%.3f", estimates[i])
      stars <- if (p_values[i] < 0.001) "***" else
               if (p_values[i] < 0.01) "** " else
               if (p_values[i] < 0.05) "* " else  ""
      paste0(est_str,stars)
    })
    names(formatted_coef) <- rownames(coef_matrix)
    return(formatted_coef)
  }

  # Extract R-squared values (Ihre Originalfunktion, keine Änderung hier)
  extract_r_squared <- function(model) {
    # ... (keine Änderung, Ihr Code bleibt hier)
    r2_values <- MuMIn::r.squaredGLMM(model) # MuMIn:: hinzugefügt für Klarheit
    return(c(
      R2m = sprintf("%.3f", r2_values[1, "R2m"]),
      R2c = sprintf("%.3f", r2_values[1, "R2c"])
    ))
  }

  # Daten extrahieren (Ihr Originalcode)
  all_coefs <- lapply(lmer_models, extract_coef_info)
  all_r_squared <- lapply(lmer_models, extract_r_squared)
  all_covariate_names <- unique(unlist(lapply(all_coefs, names)))

  if (is.null(covariate_order)) {
    covariate_order <- c("(Intercept)", sort(all_covariate_names[all_covariate_names != "(Intercept)"]))
  }
  covariate_order <- covariate_order[covariate_order %in% all_covariate_names]
  final_order <- c(covariate_order, "R2m", "R2c")

  # Matrix erstellen (Ihr Originalcode)
  results_matrix <- matrix("",
                           nrow = length(final_order),
                           ncol = length(lmer_models),
                           dimnames = list(final_order, names(lmer_models)))

  # Matrix füllen (Ihr Originalcode)
  for (model_name in names(lmer_models)) {
    model_coefs <- all_coefs[[model_name]]
    for (covar in names(model_coefs)) {
      if (covar %in% covariate_order) {
        results_matrix[covar, model_name] <- model_coefs[covar]
      }
    }
    r2_values <- all_r_squared[[model_name]]
    results_matrix["R2m", model_name] <- r2_values["R2m"]
    results_matrix["R2c", model_name] <- r2_values["R2c"]
  }

  # --- NEU: Zeilen- und Spaltennamen ersetzen ---
  
  # Ersetze die Zeilennamen (Kovariaten), falls covariate_labels übergeben wurde
  if (!is.null(covariate_labels)) {
    # Finde die Übereinstimmungen in den aktuellen Zeilennamen
    row_matches <- match(rownames(results_matrix), names(covariate_labels))
    # Ersetze nur die, die gefunden wurden
    new_rownames <- rownames(results_matrix)
    new_rownames[!is.na(row_matches)] <- covariate_labels[row_matches[!is.na(row_matches)]]
    rownames(results_matrix) <- new_rownames
  }
  
  # Ersetze die Spaltennamen (Modelle), falls model_labels übergeben wurde
  if (!is.null(model_labels)) {
    col_matches <- match(colnames(results_matrix), names(model_labels))
    new_colnames <- colnames(results_matrix)
    new_colnames[!is.na(col_matches)] <- model_labels[col_matches[!is.na(col_matches)]]
    colnames(results_matrix) <- new_colnames
  }
  
  # --- Ende der neuen Sektion ---

  # Convert to data frame for kable
  results_df <- data.frame("Predictor" = rownames(results_matrix),
                           results_matrix,
                           check.names = FALSE, # Verhindert, dass R Spaltennamen ändert
                           stringsAsFactors = FALSE)
  
  results_df
}
```

## Introduction

-   In my Internship I studied the current GRUD, particularly Mg, P and K

-   Fertilizer requirement models imply $Y\sim STP + Clay$ & $P-\text{Export}\sim STP + Clay$

-   Currently only stationary measurement of STP are considered

-   Could a kinetic desorption-model better explain the soil status and yield data?


## Experimental Setup

-   LTE STYCS, all treatment conditions equal except P-fertilization, which is in 6 Levels, 3 were considered($P0$,$P100$,$P166$)
-   4 Sites regarded; Ellighausen, Rümlang-Altwi, Oensingen, Zürich-Reckenholz
-   5 Sites, 4 blocks per site, 6 Treatment-Levels, 4 Repetitions
-   Years 2022 was modelled, kinetic data was collected for year 2022


![](https://www.agroscope.admin.ch/agroscope/en/home/topics/environment-resources/monitoring-analytics/long-term-trials/stycs/_jcr_content/par/columncontrols/items/0/column/image/image.imagespooler.jpg/1617866324311/Feld-STYCS.jpg){fig-align="center"}

## Kinetic Model

::: {.columns}

::: {.column width="45%"}
The net-desorption was modeled using a first-order kinetic equation:

**1. The Rate of Release:**
The change in P over time is proportional to the remaining desorbable P.
$$\frac{dP}{dt}=k \times (P^S-P)$$

**2. The Solution:**
When solved, this gives us the equation for the curve:
$$P(t)=P^S \times (1-e^{-kt})$$

- **$P^S$ (PS):** The maximum desorbable P pool.
- **$k$:** The first-order rate constant.

:::

::: {.column width="55%"}
```{r}
#| echo: false
#| message: false
#| warning: false
#| fig-align: "center"
#| fig-height: 7

library(ggplot2)

# Parameters for our ideal curve
PS <- 0.8 # The plateau
k <- 0.1   # The rate constant

# Create plot data
t <- seq(0, 120, length.out = 100)
P <- PS * (1 - exp(-k * t))
df_conceptual <- data.frame(t, P)

# Calculate half-life and tangent parameters
tau <- log(2) / k
P_tau <- PS / 2
slope_tau <- k * PS / 2
intercept_tau <- (PS / 2) * (1 - log(2))

# --- NEW DARKER COLORS ---
dark_purple <- "#9A51E0"
dark_orange <- "#D97F22"
dark_cyan <- "#48B6D5"
dark_green <- "#2ABD4A"

# Create a separate data frame for annotations
annotation_data <- data.frame(
  x = c(50, tau, 25),
  y = c(PS + 0.05, -0.05, 0.5),
  label = c(
    "'PS (The desorbable P pool)'",
    "paste(tau, ' = ', frac(ln(2), k), ' (Half-life)')",
    "paste('Rate at half-life = ', frac(k %*% PS, 2))"
  ),
  color = c(dark_orange, dark_cyan, dark_green), # Using new darker colors
  angle = c(0, 0, 18)
)

# Create the plot
ggplot(df_conceptual, aes(x = t, y = P)) +
  geom_line(color = dark_purple, size = 1.5) + # Using new darker purple
  geom_hline(yintercept = PS, linetype = "dashed", color = dark_orange, size = 1) + # Using new darker orange
  geom_segment(aes(x = tau, y = 0, xend = tau, yend = P_tau), linetype = "dotted", color = dark_cyan) + # Using new darker cyan
  geom_segment(aes(x = 0, y = P_tau, xend = tau, yend = P_tau), linetype = "dotted", color = dark_cyan) + # Using new darker cyan
  geom_abline(intercept = intercept_tau, slope = slope_tau, linetype = "dashed", color = dark_green, size = 1) + # Using new darker green
  geom_text(
    data = annotation_data,
    aes(x = x, y = y, label = label, color = I(color), angle = angle),
    size = 5,
    parse = TRUE
  ) +
  labs(
    title = "Simulated Kinetic Model",
    x = "Time (t)",
    y = "P desorbed (mg/L)"
  ) +
  theme_minimal(base_size = 16) +
  theme(
    plot.title = element_text(hjust = 0.5)
  ) +
  coord_cartesian(ylim = c(0, 1), clip = "off")
```
:::

:::

## Adapted Kinetic-Experiment Setup

![](Experimental_Setup.png){fig-align="center"}

## Could a kinetic desorption-model better explain the soil status and yield data?

[**Relevant Variables**]{.underline}

**Soil Variables:**

-   $P-CO_2$ & $P-AAE10$ stand for the **GRUD STP-measurements** in \[$g~P/kg ~ Soil$\]
-   $k$($s^{-1}$) can be interpreted as the **relative speed of net-desorption** of orthophosphate
-   $k*PS$($g~Ps^{-1}$) can be interpreted as the **average net-release speed**
-   $PS$($mg~P/L~H_2O$) is the **equilibrium concentration of $PO_4^{3-}$ of the net-desorption** experiment
-   From the 0-20cm Horizon: Clay-, Silt-,$C_{org}$-content and pH

**Yield Variables:**

-   For a year $X$ and crop $C$ $Y_{main-rel}$ stands for $Y_{main-rel}:=Y_C^{X}/mean(Y_C~\text{in year}~X~\text{in CH})$
-   For every year:site:crop combination the yield was normalised using: $Y_\text{norm}:=Y/median(Y_{P166})$
-   The P-Export was calculated as the **P-Uptake of the main product**
-   The P-Balance was calculated as the difference $P_{Fertilized}-\text{P-Export}$

## Research Questions

-   I: Is the **method** presented by Flossmann and Richter (1982) with the double extraction **replicable** with the soils from the **STYCS-trial**?
-   II: How do GRUD-measurements of **STP** **correlate** to the soil properties $C_\text{org}$**-content, clay-content, silt-content and pH**?
-   III: Are the kinetic coefficients $k$ **and** $PS$ **correlated to soil properties**?
-   IV: How well can current GRUD methods of **STP** ($P-CO_2$ & $P-AAE10$) **predict** the **Yield-parameters, P-Export and P-Balance**?
-   V: How well can the **kinetic parameters** $k$ & $PS$ **predict Yield-parameters, P-Export and P-Balance**?

## QI: Replicability of kinetic model in STYCS

::: notes
The estimation of the Plateau PS as proposed by Flossman und Richter was over 10 times higher than the observed concentrations in the experiment. As a consequence the linearization of the data-points did not deliver models with low $R^2$ and significant parameter estimations. To this end I took more measurements and attempted to use a non-linear-regression to simultaneously estimate PS and k. Those models were calculated for every site:treatment combination and delivered favourable predictions, although some experimantal errors or block effects were observable. 
:::


```{r}
Res <- nlsList(Pv.mg.L. ~ PS * (1 - exp(-k * (t.dt))) | uid, d[, c("Pv.mg.L.", "ui", "t.dt","uid")],  start=list(PS=0.1,k=0.2))
# summary(Res)
# d$nls_pred <- predict(Res)

# Extract coefficients from the nlsList results
nls_coefs <- coef(Res)
nls_coefs$uid <- rownames(nls_coefs)


d_plot <- merge(d, nls_coefs, by = "uid")

# Most straightforward approach - create curves manually
time_seq <- seq(min(d$t.dt, na.rm = TRUE), max(d$t.dt, na.rm = TRUE), length.out = 100)

# Create prediction data
pred_data <- d_plot %>%
  select(uid, Site, Treatment, Repetition, PS, k,ui,Pv_Olsen.mg.L.,Pv_labile.mg.L.) %>%
  distinct() %>%
  crossing(t.dt = time_seq) %>%
  mutate(pred_Pv = PS * (1 - exp(-k * (t.dt))))

hline_data <- d_plot %>%
  select(Site, Treatment, Repetition, Pv_Olsen.mg.L., Pv_labile.mg.L.) %>%
  distinct()

ggplot() +
  geom_point(data = d_plot, aes(y = Pv.mg.L., x = t.dt, col = Repetition)) +
  geom_line(data = pred_data, aes(x = t.dt, y = pred_Pv, col = Repetition), size = 0.5) +
  geom_hline(data = hline_data, 
             aes(yintercept = Pv_Olsen.mg.L.-Pv_labile.mg.L., color = Repetition),
             linetype = "dashed", size = 0.7) +
  facet_grid(Treatment ~ Site,scales = "free_y") +
  labs(x = TeX("$Time (min)$"),
       y = TeX("$P_{V}(\\frac{mg}{L})$"))
```


# QII & III: STP, k & PS correlate to soil properties?

The following random structure was chosen:

`(1|year) + (1|Site)  + (1|Site:block) + (Treatment|Site)`

## Do P-CO2, P_AAE10, k and PS correlate with soil characteristics?

```{r}
coef_table_soil <- create_coef_table(lmer_models)

# highlight_significant_cells <- function(df) {
#   df_highlighted <- df
# 
#   # Loop through data columns (excluding Covariate column)
#   for (col in names(df)[-1]) {
#     df_highlighted[[col]] <- cell_spec(df[[col]],
#                                        format = "html",
#                                        color = ifelse(grepl("\\*", df[[col]]), "red", "white"),
#                                        bold = grepl("\\*", df[[col]]))
#   }
# 
#   return(df_highlighted)
# }

highlight_significant_cells <- function(df) {
  df_highlighted <- df

  for (col in names(df)[-1]) {
    df_highlighted[[col]] <- cell_spec(df[[col]],
      format = "html",
      color = case_when(
        grepl("\\*\\*\\*", df[[col]]) ~ "red",
        grepl("\\*\\*", df[[col]])    ~ "orange",
        grepl("\\*", df[[col]])       ~ "yellow",
        TRUE                          ~ "white"
      ),
      bold = grepl("\\*", df[[col]])
    )
  }

  return(df_highlighted)
}


# Apply formatting
coef_table_soil_highlighted <- highlight_significant_cells(coef_table_soil)

# Display with kable
kable(coef_table_soil_highlighted,
      escape = FALSE,
      format = "html",
      row.names = FALSE,
      caption = "Coefficient Table for Soil Covariates.  
      Significant codes:  0 '***' 0.001 '**' 0.01 '*' 0.05") |>
  kable_styling(full_width = FALSE, position = "left")



```

::: notes
-   columns are models, rows are covariates used, cells are effects with significance
-   all but $k$ correlated to treatment
-   $k$ correlated to pH and silt
-   Plateau, P-CO2 and P-AAE10 correlated to Corg, unexpected
-   P-CO2, P-AAE10 no correlation with clay
-   P-AAE10 positive correlation to pH, surprising, should be negative
-   $k*log(PS)$ correlated to pH, silt and clay and weaker to Treatment
-   $R^2_m=0.85$ is remarkable
:::

**Observation**

-   P-CO2 and P-AAE10 did not correlate with clay-content
-   k does not correlate with Treatment but with pH and silt-content
-   $k*log(PS)$ had significant effects for clay- and silt-content as well as pH, but lower in Treatment
-   PS was the covariate best predicted by soil properties: $R^2_m=0.858$

# QIV & V: Correlation k, PS & STP to Yield and P-metrics

## Yield model summary:

```{r}


coef_table_yield <- create_coef_table(lmer_models_yield_norm)
# Apply formatting
coef_table_yield_highlighted <- highlight_significant_cells(coef_table_yield)

# Display with kable
kable(coef_table_yield_highlighted,
      escape = FALSE,
      format = "html",
      row.names = FALSE,
      caption = "Coefficient Table for Yield Variables.  
      Significant codes:  0 '***' 0.001 '**' 0.01 '*' 0.05") |>
  kable_styling(full_width = FALSE, position = "left")




```

::: notes
-   columns are models, rows are covariates used, cells are effects with significance
-   $R^2_m$ for Ynorm-models is notably hugher than Yrel
-   P-CO2 and P-AAE10 had significant effect separately, but not combined and no increase in $R^2_m$, although this is grud interpretation
-   Ynorm correlated to $k$ and $k*log(PS)$
-   Yrel did not show any correlation, except for P-AAE10,
-   for Yrel $R^2_c$ are very big comared to $R^2_m$, confounded information in the sites or normalize through national mean problematic?
:::

**Observation**

-   $k*log(PS)$ and $k$ showed the strongest effects in the prediction of Ynorm and Yrel
-   P-AAE10 did show a significant effect in prediction of Yrel

## P-Export model summary:

```{r}


coef_table_export <- create_coef_table(lmer_models_export)
# Apply formatting
coef_table_export_highlighted <- highlight_significant_cells(coef_table_export)

# Display with kable
kable(coef_table_export_highlighted,
      escape = FALSE,
      format = "html",
      row.names = FALSE,
      caption = "Coefficient Table for P-export.  
      Significant codes:  0 '***' 0.001 '**' 0.01 '*' 0.05") |>
  kable_styling(full_width = FALSE, position = "left")




```

::: notes
-   columns are models, rows are covariates used, cells are effects with significance
-   P-CO2 significant alone and in combination with P-AAE10
-   $R^2_c$ seem inflated in comparison to $R^2_m$ confounded effects?
:::

**Observations**

-   P-CO2 did show strong effects in predicting Pexport

## P-balance model summary:

```{r}


coef_table_balance <- create_coef_table(lmer_models_balance)
# Apply formatting
coef_table_balance_highlighted <- highlight_significant_cells(coef_table_balance)

# Display with kable
kable(coef_table_balance_highlighted,
      escape = FALSE,
      format = "html",
      row.names = FALSE,
      caption = "Coefficient Table for P-balance.  
      Significant codes:  0 '***' 0.001 '**' 0.01 '*' 0.05") |>
  kable_styling(full_width = FALSE, position = "left")




```

::: notes
-   columns are models, rows are covariates used, cells are effects with significance
-   P-Balance correlates strongly to PS and $R^2_m=0.52$ is substantial compared to grud STP
:::

**Observation**

-   $PS$ showed the strongest effect in predicting P_balance and k showed substantial $R^2_m$

## Concluding Remarcs

- The net-desorption of P probably follows a first-order-kinetic, but $PS$ is difficult to directly estimate.
- The kinetic parameters $k$ and $PS$ could comparably and sometimes better explain Ynorm, Yrel and P-Balance.
- Regarding the difference between $R^2_m$ and $R^2_C$ confounded effects seem to be buried in the sites.
- P-CO2 and P-AAE10 are not as well explainable as $PS$ and $k$, in particular not by clay-content.
- P-CO2 correlated however significantly with P-Export

Thank you for your attention
